---
layout: post
category : 技术
tagline: "字符串匹配"
tags : [字符串匹配]
---

# 1. 概述  
字符串匹配问题举例    
设有字符串T=abcabcabdefg，模式P=abcabd   
问：判断P是否在T中，在的话位置是多少？    
我们定义T的长度是m，P的长度是n   
列举3种算法解决这个问题: Naive算法、KMP算法、后缀树算法       

# 2. Naive算法      

## 思路   
暴力匹配，最容易想到的算法，从T[0]开始匹配P，依次尝试T[1]、T[2]到T[m-n-1]，   
空间复杂度0，时间复杂度O(m*n)

## 问题   
很明显，最简单的暴力思路太耗时了，平方级的复杂度不可接受。    
想减少时间，一般来说，需要牺牲空间，对T或者P做预处理   
前辈给出了2种“空间换时间”的方法   
-- KMP算法，对P做预处理   
   预处理时间复杂度O(n)，空间复杂度O(n)，匹配时间复杂度O(m)
---- 适合一P多T的情况，在多个T中匹配同一个P         
-- 后缀树算法，对T做预处理，对T做预处理     
   预处理时间复杂度O(m)，空间复杂度O(m^2)，匹配时间复杂度O(n)     
---- 适合一T多P的情况，在同一个T中匹配多个P


# 3. KMP算法     

## 思路  
如开头的例子，T=abcabcabdefg，P=abcabd    
abcabd 匹配T中的abcabc，d和c不同，所以匹配失败    
这时候，需要向后偏移，Naive是确定的偏移一位，所以耗时   
我们观察发现，出错位置"d"的前5位"abcab"，最长相同的前缀后缀是 "ab"    
所以，偏移到尾部的"ab"继续比较，是偏移了5-2=3位，从T[0]偏移到T[3]     

### next数组本质：计算某个字符对应的 next 值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀   

### 瘫痪分析，时间复杂度分析用到的手段，循环中出现不确定的因素时，根据某一个变量的变化，推算循环的最大复杂度        

# 4. 后缀树算法   

## 思路   
如T=abcabcdefg，后缀集合是{"g", "fg", "efg", "defg", ... "cabcabdefg", "bcabcabdefg", "abcabcabdefg"}    
把后缀树集合拼成一个前缀树(prefix tree，又叫字典树、tire树)   
前缀树是用来解决一个已知字符串是否存在的常用数据结构   
用P来匹配 这个前缀树，如果匹配成功，则P一定出现在T中   

## 本质    
T匹配P成功     
等价于    
P是T某个后缀的前缀     

## 其他    

### 广义后缀树：多个Text的后缀树   

### 后缀树能在工程上使用，是经过压缩的，怎么压缩的，老衲记不清了，有时间再起一篇吧     

### 后缀树还能解决的问题：最长重复字串、最长回文...   


# 参考文章
* [KMP算法Matrix67](http://www.matrix67.com/blog/archives/115)
* [KMP极客学院](http://wiki.jikexueyuan.com/project/kmp-algorithm/define.html)
