---
layout: post
category : 技术
tagline: "红黑树 B树 R树"
tags : [平衡树]
---

# 1. 概述  
本文只说抽象思考后得出的简单思路，没有实现细节，这也是我一直以来的习惯，理解了思路，是学习的第一步。   
二叉查找树是一个很重要的数据结构，可以解决排序和查找问题。由此衍生出的数据结构包括AVL树、2-3树、红黑树、B树、B+树、B*树、R树等等  

# 2. 二分查找树的问题   

## 2个问题困扰严重   
1. 高度的控制，太高的树，IO开销大   
2. 平衡问题，考虑到平均情况，左子树右子树高度不要差太多   

## 问题的根源是什么呢   
1. 高度问题，只能通过增加宽度来解决，代表是B树系列，所以数据库使用了B+树   
2. 平衡问题的根源，宽度太小   
只有2叉，连续插入N个点，都落在左边的概率是0.5的N次方，4叉树 8叉树 都落在最左边的概率会变小  

### 有2个解决思路  
-- 多叉树，比如cisco路由器有种256叉树，这种方案遇到稀疏节点，太浪费空间  
-- 动态平衡，想办法在插入节点的时候，对树做“旋转”操作，维持2边的平衡，代表是AVL树、2-3树、红黑树   

# 3. 几种平衡树 AVL 2-3树 红黑树   

## 3.1 AVL树   
1. 左子树右子树高度差不能大于1，每次插入、删除都要旋转一下   
2. **问题**   
-- 维护成本太大，适用于查找多插入少的场景   

## 3.2 2-3树   
1. 指导思想：宽度和高度的博弈，通过增加一个宽度来抵消插入带来的高度   
-- 不用那么频繁的“旋转”
2. 节点分2类，2节点和3节点，对于插入的处理   
    -- 父节点是2节点，很好办，变成3节点就行了，宽度加1，高度不变   
    -- 父节点是3节点，高度肯定要加1了(先变4节点，再分裂，保证本子树平衡)，然后只能往祖先节点追溯了    
    ---- 遇到一个2节点，变成3节点就解决了   
    ---- 到根节点都是3节点，把根变成4节点，再分裂     
3. **问题**  
-- 不是2叉树了，有3叉，操作不方便   

## 3.3 红黑树    
1. 基于2-3树的变体，保证2叉树的简便操作，用红色模拟3节点，黑色模拟2节点   
2. **问题**   
-- 不再是完美平衡了，最差情况下左子树全是红色节点，左子树高度是右子树的2倍   

## 3.4 跳表(忍不住想在这里插入一段)   
1. 链表基础上，多加几层链表，查找、插入复杂度是lgN    
2. 优点是实现简单    

# 4. B树系列    

## 4.1 B树   
1. 多叉树，m阶B树最多有m叉，最少不能低于m/2叉，当然还有别的一些要求balabala   
2. 节点如果存储x个key，则有x+1个子节点    
3. 明显是宽度换高度，减少IO开销   

## 4.2 B+树(数据库采用)    
1. 数据data都在叶子节点上，非叶子节点都是索引index    
2. 非叶子节点只有索引，占空间小，一次磁盘IO可以读出更多数据，适合数据库使用    

## 4.3 B*树   
1. 节点上还维护兄弟节点的指针   
2. 优点    
-- 更高的空间使用率，1个节点满了，可以找兄弟节点，减少了分配新节点的概率   
-- 方便做rank_query，叶子节点组成了单链表   


# 5. R树 和 geohash   

## 5.1 R树   
1. 解决高维空间搜索问题   
2. 划分不同大小(层级)的矩形块，最小的块在叶子节点，最大的块在顶层   
3. 查找时，从最大块开始，沿着树，逐渐缩小查询矩形块    


## 5.2 geohash(说到R树不得不提一下)    
1. 对经纬度不断的等分，比如：维度>0用1表示，<0用1表示，>45用11表示，<45用10表示  
-- 每一位都只取1或0，明显前缀一样，表示2个位置距离近    
2. 奇数位纬度，偶数位经度，拼成1个新串，base32编码    
3. 对geohash做前缀匹配可以查找附近的点    
-- 只适合点得查找，如果线和面，还是得用R树   



# 参考文章
* [B树系列](http://blog.csdn.net/v_july_v/article/details/6530142)   
* [真正理解红黑树](http://dog250.blog.51cto.com/2466061/1668601)   
* [跳表](http://kenby.iteye.com/blog/1187303)   

